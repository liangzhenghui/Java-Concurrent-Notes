### Fork/Join框架

- 本节将会介绍Fork/Join框架的基本原理、算法、设计方式、应用与实现等。

##### 什么是Fork/Join框架

- Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。
- 我们再通过Fork和Join这两个单词来理解一下Fork/Join框架。
  - Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。
  - 比如计算1+2+…+10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。
- Fork/Join的运行流程如下图所示。![Fork Join的运行流程图](https://github.com/walmt/Java-Concurrent-Notes/blob/master/img/119.png?raw=true)

##### 工作窃取算法

- 工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。
- 那么，为什么需要使用工作窃取算法呢？
  - 假如我们需要做一个比较大的任务，可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。
  - 比如A线程负责处理A队列里的任务。
    - 但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。
    - 干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。
    - 而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。
- 工作窃取的运行流程如下图所示。![工作窃取运行流程图](https://github.com/walmt/Java-Concurrent-Notes/blob/master/img/120.png?raw=true)
- **工作窃取算法的优点**：
  - 充分利用线程进行并行计算，减少了线程间的竞争。
- **工作窃取算法的缺点**：
  - 在某些情况下还是存在竞争，比如双端队列里只有一个任务时。
  - 并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。

##### Fork/Join框架的设计

- 我们已经很清楚Fork/Join框架的需求了，那么可以思考一下，如果让我们来设计一个Fork/Join框架，该如何设计？这个思考有助于你理解Fork/Join框架的设计。

- **步骤1　分割任务。**

  - 首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。

- **步骤2　执行任务并合并结果。**

  - 分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。
  - 子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。

- Fork/Join使用两个类来完成以上两件事情。

  1. ForkJoinTask：

     - 我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。
     - 它提供在任务中执行fork()和join()操作的机制。
     - 通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。

     RecursiveAction：

     - 用于没有返回结果的任务。

  2. ForkJoinPool：

     - ForkJoinTask需要通过ForkJoinPool来执行。

- 任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。

- 当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。

##### 使用Fork/Join框架

- ​