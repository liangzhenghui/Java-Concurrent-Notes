### volatile的内存语义

- 当声明共享变量为volatile后，对这个变量的读/写将会很特别。

##### volatile的特性

- 理解volatile特性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。

```Java
public class VolatileFeaturesExample {

    volatile long v1 = 0L;  //使用volatile声明64位的long型变量

    public void set(long l) {   //单个volatile变量的写
        v1 = l;
    }

    public void getAndIncrement() { //复合（多个）volatile变量的读/写
        v1++;
    }

    public long get() { //单个volatile变量的读
        return v1;
    }
}
```

- 等价于：

```Java
public class VolatileFeaturesExample {

    long v1 = 0L;  //使64位的long型变量
  
    public synchronized void set(long l) {   //对单个的普通变量的写用同一个锁同步
        v1 = l;
    }
  
    public void getAndIncrement() { //普通方法调用
        long temp = get();          //调用已同步的读方法
        temp += 1L;                 //普通写操作
        set(temp);                  //调用已同步的写方法
    }

    public synchronized long get() { //对单个的普通变量的读用同一个锁同步
        return v1;
    }
}
```

- 如上面示例程序所示，一个volatile变量的单个读/写操作，与一个普通变量的读/写操作都是使用同一个锁来同步，它们之间的执行效果相同。
- 锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
- 锁的语义决定了临界区代码的执行具有原子性。这意味着，即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。
- 如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。
- volatile变量自身具有下列特性:
  1. 可见性。
     - 对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
  2. 原子性：
     - 对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。

##### volatile写-读建立的happens-before关系

- 从JSR-133开始（即从JDK5开始），volatile变量的写-读可以实现线程之间的通信。
- 从内存语义的角度来说，volatile的写-读与锁的释放-获取有相同的内存效果：
  - volatile写和锁的释放有相同的内存语义；
  - volatile读与锁的获取有相同的内存语义。
- 请看下面使用volatile变量的示例代码:

```Java
class VolatileExample {
  
    int a = 0;
  	
  	volatile boolean flag = false;
  
  	public void writer() {
    	a = 1;	//1
      	flag = true;	//2
    }
  
  	public void reader() {
        if (flag) {	//3
            int i = a;	//4
          	//……
        }
    }
}
```

- 假设线程A执行writer()方法之后，线程B执行reader()方法。
- （在4能执行的情况下）根据happens-before规则，这个过程建立的happens-before关系可以分为3类：
  1. 根据程序次序规则，1 happens-before 2;3 happens-before 4。
  2. 根据volatile规则，2 happens-before 3。
  3. 根据happens-before的传递性规则，1 happens-before 4。
- 上述happens-before关系的图形化表现形式如下。![happens-before关系](https://github.com/walmt/Java-Concurrent-Notes/blob/master/img/30.png?raw=true)
- 在上图中，每一个箭头链接的两个节点，代表了一个happens-before关系。
  - 黑色箭头表示程序顺序规则；
  - 橙色箭头表示volatile规则；
  - 蓝色箭头表示组合这些规则后提供的happens-before保证。
- 这里A线程写一个volatile变量后，B线程读同一个volatile变量。
- A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。

##### volatile写-读的内存语义

- volatile写的内存语义如下：
  - 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。
  - 以上面示例程序VolatileExample为例，假设线程A首先执行writer()方法，随后线程B执行reader()方法，初始时两个线程的本地内存中的flag和a都是初始状态。
  - 下图是线程A执行volatile写后，共享变量的状态示意图。![共享变量的状态示意图](https://github.com/walmt/Java-Concurrent-Notes/blob/master/img/31.png?raw=true)
  - 线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。
- volatile读的内存语义如下：
  - 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。
  - 下图为线程B读同一个volatile变量后，共享变量的状态示意图。![共享变量的状态示意图](https://github.com/walmt/Java-Concurrent-Notes/blob/master/img/32.png?raw=true)
  - 如图所示，在读flag变量后，本地内存B包含的值已经被置为无效。
  - 此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值变成一致。
  - 如果我们把volatile写和volatile读两个步骤综合起来看的话，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程B可见。
- 下面对volatile写和volatile读的内存语义做个总结：
  - 线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。
  - 线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。
  - 线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。

##### volatile内存语义的实现

- ​