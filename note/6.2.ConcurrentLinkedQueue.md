### ConcurrentLinkedQueue

- 在并发编程中，有时候需要使用线程安全的队列。如果要实现一个线程安全的队列有两种方式：
  - 一种是使用阻塞算法，另一种是使用非阻塞算法。
  - 使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。
- 本节让我们一起来研究一下Doug Lea是如何使用非阻塞的方式来实现线程安全队列ConcurrentLinkedQueue的，相信从大师身上我们能学到不少并发编程的技巧。
- ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序。
  - 当我们添加一个元素的时候，它会添加到队列的尾部；
  - 当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait-free”算法（即CAS算法）来实现，该算法在Michael&Scott算法上进行了一些修改。

### ConcurrentLinkedQueue的结构

- 通过ConcurrentLinkedQueue的类图来分析一下它的结构，如下图所示。![ConcurrentLinkedQueue的类图](https://github.com/walmt/Java-Concurrent-Notes/blob/master/img/108.png?raw=true)
- ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。
- 默认情况下head节点存储的元素为空，tail节点等于head节点。

```Java
private transient volatile Node<E> tail = head;
```

##### 入队列

- 本节将介绍入队列的相关知识。

1. **入队列的过程**
   - 入队列就是将入队节点添加到队列的尾部。
   - 为了方便理解入队时队列的变化，以及head节点和tail节点的变化，这里以一个示例来展开介绍。
   - 假设我们想在一个队列中依次插入4个节点，为了帮助大家理解，每添加一个节点就做了一个队列的快照图，如下图所示。![队列添加元素的快照图](https://github.com/walmt/Java-Concurrent-Notes/blob/master/img/109.png?raw=true)
   - 上图所示的过程如下。
     - **添加元素1**
       - 队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。
     - **添加元素2**
       - 队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。
     - **添加元素3**
       - 设置tail节点的next节点为元素3节点。
     - **添加元素4**
       - 设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。
   - 通过调试入队过程并观察head节点和tail节点的变化，发现入队主要做两件事情：
     - 第一是将入队节点设置成当前队列尾节点的下一个节点；
     - 第二是更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点（理解这一点对于我们研究源码会非常有帮助）。