### 重入锁

- 重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。
- 回忆在同步器一节中的示例（Mutex），同时考虑如下场景：
  - 当一个线程调用Mutex的lock()方法获取锁之后，如果再次调用lock()方法，则该线程将会被自己所阻塞，原因是Mutex在实现tryAcquire(int acquires)方法时没有考虑占有锁的线程再次获取锁的场景，而在调用tryAcquire(int acquires)方法时返回了false，导致该线程被阻塞。
- 简单地说，Mutex是一个不支持重进入的锁。
- 而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁，而不像Mutex由于获取了锁，而在下一次获取锁时出现阻塞自己的情况。
- ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。
- 这里提到一个锁获取的公平性问题，如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。
  - 公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。
  - ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。
- 事实上，公平的锁机制往往没有非公平的效率高，但是，并不是任何场景都是以TPS作为唯一的指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。
- 下面将着重分析ReentrantLock是如何实现重进入和公平性获取锁的特性，并通过测试来验证公平性获取锁对性能的影响。

1. **实现重进入**

   - 重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。

   1. **线程再次获取锁**。
      - 锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。
   2. **锁的最终释放**。
      - 线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。
      - 锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。

   - ReentrantLock是通过组合自定义同步器来实现锁的获取与释放，以非公平性（默认的）实现为例，获取同步状态的代码如下列代码所示。

   ```Java
   final boolean nonfairTryAcquire(int acquires) {
       final Thread current = Thread.currentThread();
       int c = getState();
       if (c == 0) {
           if (compareAndSetState(0, acquires)) {
               setExclusiveOwnerThread(current);
               return true;
           }
       }
       else if (current == getExclusiveOwnerThread()) {
           int nextc = c + acquires;
           if (nextc < 0) // overflow
               throw new Error("Maximum lock count exceeded");
           setState(nextc);
           return true;
       }
       return false;
   }
   ```

   - 该方法增加了再次获取同步状态的处理逻辑：
     - 通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。
   - 成功获取锁的线程再次获取锁，只是增加了同步状态值，这也就要求ReentrantLock在释放同步状态时减少同步状态值，该方法的代码如下列代码所示。

   ```Java
   protected final boolean tryRelease(int releases) {
       int c = getState() - releases;
       if (Thread.currentThread() != getExclusiveOwnerThread())
           throw new IllegalMonitorStateException();
       boolean free = false;
       if (c == 0) {
           free = true;
           setExclusiveOwnerThread(null);
       }
       setState(c);
       return free;
   }
   ```

   - 如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。
   - 可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。

2. **公平与非公平获取锁的区别**

   - 公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。
   - 回顾上一小节中介绍的nonfairTryAcquire(int acquires)方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同，如下列代码所示。

   ```Java
   protected final boolean tryAcquire(int acquires) {
       final Thread current = Thread.currentThread();
       int c = getState();
       if (c == 0) {
           if (!hasQueuedPredecessors() &&
               compareAndSetState(0, acquires)) {
               setExclusiveOwnerThread(current);
               return true;
           }
       }
       else if (current == getExclusiveOwnerThread()) {
           int nextc = c + acquires;
           if (nextc < 0)
               throw new Error("Maximum lock count exceeded");
           setState(nextc);
           return true;
       }
       return false;
   }
   ```

   - 该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。
   - 下面编写一个测试来观察公平和非公平锁在获取锁时的区别，在测试用例中定义了内部类ReentrantLock2，该类主要公开了getQueuedThreads()方法，该方法返回正在等待获取锁的线程列表，由于列表是逆序输出，为了方便观察结果，将其进行反转，测试用例（部分）如下列代码所示。

   ```Java
   public class FairAndUnfairTest {
       private static ReentrantLock2 fairLock = new ReentrantLock2(true);
       private static ReentrantLock2 unfairLock = new ReentrantLock2(false);

       public static void main(String[] args) {
           FairAndUnfairTest fairAndUnfairTest = new FairAndUnfairTest();
   //        fairAndUnfairTest.testLock(fairLock);
           fairAndUnfairTest.testLock(unfairLock);
       }

       private void testLock(ReentrantLock2 lock) {
           Job[] jobs = new Job[5];
           for (int i = 0; i < jobs.length; i++) {
               jobs[i] = new Job(lock);
           }
           for (int i = 0; i < jobs.length; i++) {
               jobs[i].start();
           }
       }

       private static class Job extends Thread {
           private ReentrantLock2 lock;
           public Job(ReentrantLock2 lock) {
               this.lock = lock;
           }
           public void run() {
               for (int i = 0; i < 2; i++) {
                   try {
                       lock.lock();
                       System.out.print("Lock by [" + currentThread().getId() + "], ");
                       System.out.print("Waiting  by [");
                       lock.getQueuedThreads().forEach(t-> System.out.print(t.getId() + ","));
                       System.out.println("]");
                   } finally {
                       lock.unlock();
                   }
               }
           }
       }

       private static class ReentrantLock2 extends ReentrantLock {
           public ReentrantLock2(boolean fair) {
               super(fair);
           }

           public Collection<Thread> getQueuedThreads() {
               List<Thread> arrayList = new ArrayList<Thread>(super.getQueuedThreads());
               Collections.reverse(arrayList);
               return arrayList;
           }
       }
   }
   ```

   - 分别运行fair()和unfair()两个测试方法，输出结果如下表所示。![fair()和unfair()两个测试方法的输出结果]()
   - ​